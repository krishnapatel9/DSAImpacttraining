convert integer to bytecode without using string

while(a%2!=1)
    if(a%2 != 0)
         bytecode=1
    else
         bytecode=0
result=bytecode.reverse()



divide integer with 2 
bytecode : append the remainder
quotient will be new integer (integer/2)
reverse the bytecode

bytexcode=0;                           sum=0;
index=1;                               place=1;
int value;                             int n;
while (quotient != 1){                  while (n>0)
   rem=value%2;                            rem=n%2   
   bytecode.append(rem);                   bytecode=bytecode+rem*index
                                           index=index*10
                                           n=n/2

int sum=0;
int place=1;
        while(n>0){
            int rem = n%2;
            sum=sum+rem*place;
            place=place*10;
            
            n=n/2;
convert binary to integer:
int sum=0;
int base=1;
 while(n>0){
            int rem = n%2;
            sum=sum+rem*base;
            base=base*2;
            
            n=n/2;

for bytecode : last digit = 1 (odd) vice versa
& -->bitwise operator
&&-->logical operator
swap 2 variable without using 3rd variable by implementing xor 

1's complement : 0-->1,1-->0
2's complement : last bit of 1's complement + 1 
31st bit is signed bit : 1-->negative and 0--> positive
larget 32 bit digit :2^32-1(inbuilt method:Integer.MAX_VALUE)
smallest 32 bit digit: -2^31(signed bit is -)Integer.MIN_VALUE
positive 2's complement of  number = negative of that number

not operator:
flip all the bits
if its neg: convert to its 2's complement

shifting
left shift:
21<<1
(21)n*2^k(1)
-->42

right shift:
21>>1
10101 == 21
01010 == 10
n/2^k
21/2^1=21/2=10

21>>3==2
set bit=1

finding ith as set bit?
n=23
i=3,2
10111
No,Yes

int sum =0;
int place=1;

//set bit or not
place 1 at i th index,so perform left shift
n=21
10101
00100
& operator (probability(getting 1)=1 and also > 0 )
parallel of 1 to ith place by left shift, and perform & operation

//left shift
if ((n&(1<<i))==0):
   return False;
else:
   return True;


//right shift
shift n to its right side i th times
last bit & 00001 >0  return true
if((n>>i)&1) !=0  return true

convert ith bit as set bit
strictly cant use right shift operator
if ((n&(1<<i))==0):
  i=1;

i=2
25=11001
   00100 1<<i
   11101
s.o.p(n (1<<i))

